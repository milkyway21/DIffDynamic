# n_repeat 和 cycles 参数详细说明

## 概述

`n_repeat` 和 `cycles` 是动态采样模式中的两个关键参数，它们分别控制**大步探索阶段**和**精炼阶段**的重复次数，目的是通过多轮次采样来提高生成分子的质量和多样性。

---

## 一、n_repeat（大步探索阶段的重复次数）

### 1.1 参数位置
```yaml
dynamic:
  large_step:
    n_repeat: 4  # 重复次数
    batch_size: 16  # 每轮处理的候选数量
```

### 1.2 作用机制

**代码位置**: `scripts/sample_diffusion.py:304`

```python
for repeat_idx in range(n_repeat):  # 逐次执行大步探索
    # 每次重复都会：
    # 1. 生成新的随机初始位置和类别
    # 2. 执行一次完整的大步探索采样
    # 3. 生成 batch_size 个候选
    res = model.sample_diffusion_large_step(...)
    # 收集所有候选
    total_candidates.append(candidate)
```

### 1.3 为什么需要多轮次？

#### 目的1：增加候选多样性
- **单次采样**：从一组固定的初始状态开始，可能陷入局部最优
- **多次重复**：每次重复使用**不同的随机初始状态**，探索不同的搜索空间
- **结果**：获得更多样化的候选分子

#### 目的2：提高找到高质量候选的概率
- 扩散采样具有随机性，单次采样可能生成质量较差的分子
- 多次重复相当于"多次尝试"，增加找到高质量候选的机会
- 类似于蒙特卡洛方法中的多次采样

#### 目的3：扩大候选池
- **总候选数** = `n_repeat` × `batch_size`
- 例如：`n_repeat=4, batch_size=16` → 总共生成 **64个候选**
- 更大的候选池 → 更有可能找到高质量分子

### 1.4 工作流程示例

```
n_repeat = 4, batch_size = 16

第1轮 (repeat_idx=0):
  ├─ 生成16个随机初始状态
  ├─ 执行大步探索（时间步 1000→500）
  └─ 得到16个候选

第2轮 (repeat_idx=1):
  ├─ 生成16个新的随机初始状态（与第1轮不同）
  ├─ 执行大步探索（时间步 1000→500）
  └─ 得到16个候选

第3轮 (repeat_idx=2):
  └─ ...（同上）

第4轮 (repeat_idx=3):
  └─ ...（同上）

总计：64个候选 → 选择 top_n=12 个最佳候选
```

### 1.5 显存和时间影响

- **显存**：每轮重复独立执行，显存使用相同（约6GB）
- **时间**：总时间 = 单次时间 × n_repeat
  - 单次：8-15秒
  - 4次：32-60秒

### 1.6 参数调优建议

| n_repeat | 候选总数 | 优点 | 缺点 | 适用场景 |
|----------|---------|------|------|----------|
| 1 | 16 | 速度快 | 多样性低 | 快速测试 |
| 2 | 32 | 平衡 | - | 一般使用 |
| 4 | 64 | 多样性高 | 时间较长 | **推荐**（当前配置） |
| 8 | 128 | 多样性很高 | 时间很长 | 追求最高质量 |

---

## 二、cycles（精炼阶段的循环次数）

### 2.1 参数位置
```yaml
dynamic:
  refine:
    cycles: 1  # 重复精炼的轮数
    time_upper: 500  # 精炼起始时间步
    time_lower: 0    # 精炼结束时间步
```

### 2.2 作用机制

**代码位置**: `models/molopt_score_model.py:1129`

```python
ligand_pos_current, log_ligand_v_current = ligand_pos, log_ligand_v
for _ in range(max(int(num_cycles), 1)):  # 重复执行若干周期
    # 每次cycle都会：
    # 1. 从当前状态开始（上一次cycle的结果）
    # 2. 执行一次完整的精炼过程（time_upper → time_lower）
    # 3. 更新当前状态
    ligand_pos_current, log_ligand_v_current, ... = self._dynamic_diffusion(
        ligand_pos=ligand_pos_current,  # 使用上一次的结果
        log_ligand_v=log_ligand_v_current,
        time_indices=time_indices,  # time_upper → time_lower
        ...
    )
```

### 2.3 为什么需要多轮次？

#### 目的1：逐步优化结构
- **单次精炼**：从大步探索的结果开始，执行一次精炼（500→0）
- **多次循环**：每次循环都会基于**上一次的结果**继续优化
- **效果**：逐步细化分子结构，提高局部最优解的质量

#### 目的2：增强收敛稳定性
- 扩散采样可能在某些时间步出现数值不稳定
- 多次循环可以让优化过程更加稳定，避免单次精炼的偶然误差

#### 目的3：精细调整
- 第一次cycle：粗调，快速接近目标
- 后续cycles：细调，在局部区域进一步优化

### 2.4 工作流程示例

```
cycles = 2, time_upper = 500, time_lower = 0

初始状态（来自大步探索）:
  └─ ligand_pos_0, log_ligand_v_0

第1个cycle:
  ├─ 输入：ligand_pos_0, log_ligand_v_0
  ├─ 执行精炼：时间步 500 → 400 → 300 → ... → 0
  └─ 输出：ligand_pos_1, log_ligand_v_1

第2个cycle:
  ├─ 输入：ligand_pos_1, log_ligand_v_1（使用第1个cycle的结果）
  ├─ 执行精炼：时间步 500 → 400 → 300 → ... → 0（再次完整执行）
  └─ 输出：ligand_pos_2, log_ligand_v_2（最终结果）
```

### 2.5 与 n_sampling 的区别

**重要**：`cycles` 和 `n_sampling` 是两个不同的概念！

| 参数 | 作用范围 | 输入状态 | 目的 |
|------|---------|---------|------|
| **cycles** | 精炼阶段内部 | 每次cycle使用上一次的结果 | 逐步优化同一个候选 |
| **n_sampling** | 精炼阶段外部 | 每次sampling从同一个初始候选开始 | 生成多个独立的精炼结果 |

**代码示例**：
```python
# n_sampling = 2, cycles = 2
for cand in selected_candidates:  # 遍历12个候选
    for refine_idx in range(n_sampling):  # 对每个候选执行2次独立精炼
        # 第1次sampling（cycles=2）:
        #   cycle 1: 初始候选 → 精炼结果1
        #   cycle 2: 精炼结果1 → 精炼结果2（最终）
        
        # 第2次sampling（cycles=2）:
        #   cycle 1: 初始候选 → 精炼结果1（重新开始）
        #   cycle 2: 精炼结果1 → 精炼结果2（最终）
```

### 2.6 显存和时间影响

- **显存**：cycles在单次精炼内部执行，显存使用相同（约3.5GB）
- **时间**：总时间 = 单次精炼时间 × cycles
  - 单次精炼：5-12秒
  - cycles=2：10-24秒

### 2.7 参数调优建议

| cycles | 优化程度 | 优点 | 缺点 | 适用场景 |
|--------|---------|------|------|----------|
| 1 | 基础 | 速度快 | 可能未充分优化 | 快速测试 |
| 2 | 较好 | 平衡 | - | **推荐**（追求质量） |
| 3 | 很好 | 质量高 | 时间较长 | 追求最高质量 |
| 4+ | 过度 | 质量提升有限 | 时间显著增加 | 通常不推荐 |

---

## 三、参数组合效果

### 3.1 当前配置（优化后）
```yaml
large_step:
  batch_size: 16
  n_repeat: 4
  # 总候选数：16 × 4 = 64

selector:
  top_n: 12
  # 选择12个最佳候选

refine:
  n_sampling: 2
  cycles: 1
  # 对每个候选执行2次独立精炼，每次精炼内部1个cycle
```

### 3.2 工作流程总览

```
1. 大步探索阶段（n_repeat=4）:
   └─ 生成 64 个候选

2. 候选评估:
   └─ 计算每个候选的QED、SA等指标

3. 候选筛选:
   └─ 选择 top_n=12 个最佳候选

4. 精炼阶段（n_sampling=2, cycles=1）:
   └─ 对每个候选执行2次独立精炼
       └─ 每次精炼：1个cycle（500→0）
   └─ 总共生成 12 × 2 = 24 个精炼结果
```

### 3.3 不同配置对比

| 配置 | n_repeat | cycles | 候选数 | 精炼结果数 | 总时间 | 质量 |
|------|---------|--------|--------|-----------|--------|------|
| **快速** | 2 | 1 | 32 | 12 | ~3分钟 | 中等 |
| **推荐** | 4 | 1 | 64 | 24 | ~5分钟 | 较好 |
| **高质量** | 4 | 2 | 64 | 24 | ~8分钟 | 很好 |
| **最高质量** | 8 | 2 | 128 | 24 | ~15分钟 | 最好 |

---

## 四、为什么需要多轮次？总结

### 4.1 n_repeat（大步探索）
- **目的**：增加候选多样性，提高找到高质量候选的概率
- **机制**：每次重复使用不同的随机初始状态
- **效果**：扩大候选池，增加选择空间

### 4.2 cycles（精炼阶段）
- **目的**：逐步优化结构，增强收敛稳定性
- **机制**：每次cycle基于上一次的结果继续优化
- **效果**：提高局部最优解的质量

### 4.3 设计理念

```
大步探索（n_repeat）: 广度优先
  └─ 探索不同的搜索空间
  └─ 找到多个有潜力的候选

精炼阶段（cycles）: 深度优先
  └─ 在局部区域深度优化
  └─ 提高单个候选的质量
```

### 4.4 权衡考虑

- **增加轮次** → 提高质量，但增加时间
- **减少轮次** → 节省时间，但可能降低质量
- **推荐配置**：在质量和时间之间取得平衡

---

## 五、实际使用建议

### 5.1 16GB显存配置（当前）
```yaml
large_step:
  n_repeat: 4  # 平衡多样性和时间
  batch_size: 16  # 适配显存

refine:
  cycles: 1  # 单次精炼已足够
  n_sampling: 2  # 增加结果多样性
```

### 5.2 如果显存充足
```yaml
large_step:
  n_repeat: 4-6  # 可以增加
  batch_size: 20-24  # 可以增加

refine:
  cycles: 2  # 可以增加，提高质量
  n_sampling: 2-3  # 可以增加
```

### 5.3 如果追求速度
```yaml
large_step:
  n_repeat: 2  # 减少
  batch_size: 16  # 保持不变

refine:
  cycles: 1  # 保持不变
  n_sampling: 1  # 减少
```

---

## 六、常见问题

### Q1: n_repeat 和 batch_size 有什么区别？
- **batch_size**：单次并行处理的候选数量（影响显存）
- **n_repeat**：重复执行大步探索的次数（影响总候选数）

### Q2: cycles 和 n_sampling 有什么区别？
- **cycles**：在单次精炼内部，多次迭代优化（使用上一次结果）
- **n_sampling**：对同一候选执行多次独立的精炼（从同一初始状态开始）

### Q3: 增加 n_repeat 还是增加 batch_size？
- **增加 batch_size**：更快，但显存需求高
- **增加 n_repeat**：更灵活，显存需求不变，但时间增加

### Q4: cycles=2 是否一定比 cycles=1 好？
- 不一定，取决于具体任务
- cycles=2 通常质量更好，但时间增加约2倍
- 建议先测试 cycles=1，如果质量不够再增加

---

## 七、总结

- **n_repeat**：通过多次重复大步探索，增加候选多样性，提高找到高质量候选的概率
- **cycles**：通过多次循环精炼，逐步优化结构，提高局部最优解的质量
- **多轮次的目的**：在探索（广度）和优化（深度）之间取得平衡，提高最终生成分子的质量

