# 修复原子数采样问题

## 问题描述

错误：`RuntimeError: repeats can not be negative`

发生在 `_run_legacy_dynamic` 函数中，当使用 `prior` 模式采样原子数时。

## 问题原因

`atom_num.sample_atom_num(pocket_size)` 可能返回：
1. **负数**：如果 `pocket_size` 计算异常（NaN、负数等）
2. **零**：如果采样到 0（虽然 CONFIG 中应该没有 0）
3. **无效值**：如果 `pocket_size` 导致 `bin_idx` 超出范围

## 可能的原因

1. **口袋为空或原子数太少**：如果 `data.protein_pos` 为空或只有很少原子，`get_space_size` 可能返回 NaN
2. **数据异常**：某些测试集样本的蛋白数据可能有问题

## 临时解决方案

在采样原子数时添加检查和防护：

```python
# 在 _run_legacy_dynamic 函数中，第 310-316 行附近
if sample_num_atoms_mode == 'prior':
    pocket_size = atom_num.get_space_size(data.protein_pos.detach().cpu().numpy())
    
    # 添加检查和防护
    if np.isnan(pocket_size) or pocket_size <= 0:
        # 使用默认值
        pocket_size = 30.0  # 使用中等大小的默认值
        if logger:
            logger.warning(f'Invalid pocket_size: {pocket_size}, using default 30.0')
    
    ligand_num_atoms = []
    for _ in range(n_data):
        num_atoms = int(atom_num.sample_atom_num(pocket_size))
        # 确保原子数有效
        if num_atoms <= 0:
            num_atoms = 10  # 使用默认最小值
            if logger:
                logger.warning(f'Invalid num_atoms sampled: {num_atoms}, using default 10')
        ligand_num_atoms.append(num_atoms)
    
    batch_ligand = torch.repeat_interleave(
        torch.arange(n_data, device=device, dtype=torch.long),
        torch.tensor(ligand_num_atoms, device=device, dtype=torch.long)
    )
```

## 检查当前数据

运行以下命令检查当前样本的蛋白数据：

```python
import torch
from datasets import get_dataset
import utils.transforms as trans
from torch_geometric.transforms import Compose

ckpt = torch.load('pretrained_models/pretrained_diffusion.pt', map_location='cpu')
config = ckpt['config']

protein_featurizer = trans.FeaturizeProteinAtom()
ligand_atom_mode = config.data.transform.ligand_atom_mode
ligand_featurizer = trans.FeaturizeLigandAtom(ligand_atom_mode)
transform = Compose([
    protein_featurizer,
    ligand_featurizer,
    trans.FeaturizeLigandBond(),
])

dataset, subsets = get_dataset(config=config.data, transform=transform)
test_set = subsets['test']

# 检查索引 5 的数据
data = test_set[5]
print(f"蛋白原子数: {data.protein_pos.shape[0]}")
print(f"蛋白位置形状: {data.protein_pos.shape}")

# 检查 pocket_size
from utils.evaluation import atom_num
pocket_size = atom_num.get_space_size(data.protein_pos.detach().cpu().numpy())
print(f"Pocket size: {pocket_size}")
print(f"Is NaN: {np.isnan(pocket_size)}")
print(f"Is valid: {pocket_size > 0}")

# 测试采样
try:
    num_atoms = atom_num.sample_atom_num(pocket_size)
    print(f"Sampled num_atoms: {num_atoms}")
except Exception as e:
    print(f"采样失败: {e}")
```

## 根本解决方案

需要修复代码以处理边界情况。但根据您的要求"先不要改代码"，这里只是分析问题原因。

## 快速绕过方法

如果只是想快速测试，可以：

1. **使用不同的采样模式**：修改配置文件使用 `range` 模式而不是 `prior` 模式
2. **使用不同的测试样本**：尝试其他索引（如 0, 1, 2）看是否有同样问题
3. **检查数据质量**：确保测试集中的数据都是有效的

