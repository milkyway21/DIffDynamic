# 为什么修改后参数能正常使用 - 详细解释

## 问题根源

### 修改前的问题流程

```
1. 模型初始化时（models/molopt_score_model.py:297-298）
   ↓
   self.dynamic_large_step_defaults = getattr(config, 'dynamic_large_step', {})
   self.dynamic_refine_defaults = getattr(config, 'dynamic_refine', {})
   ↓
   ❌ 这里读取的是训练配置文件（training.yml）中的配置，不是 sampling.yml
   
2. _run_unified_dynamic 函数调用 dynamic_sample_diffusion
   ↓
   result = model.dynamic_sample_diffusion(...)
   ↓
   ❌ 只传递了 num_steps, center_pos_mode, pos_only
   ❌ 没有传递 dynamic.large_step 和 dynamic.refine 配置
   
3. dynamic_sample_diffusion 方法内部（models/molopt_score_model.py:1290-1291）
   ↓
   large_cfg = self.dynamic_large_step_defaults or {}  # 读取模型属性
   refine_cfg = self.dynamic_refine_defaults or {}      # 读取模型属性
   ↓
   ❌ 这里读取的是训练时的默认值，不是 sampling.yml 中的值
   
4. 使用配置参数
   ↓
   step_size=large_cfg.get('step_size')  # 使用训练时的默认值
   stride=large_cfg.get('stride')        # 使用训练时的默认值
   ↓
   ❌ sampling.yml 中的配置被完全忽略
```

## 修改后的解决方案

### 修改后的正确流程

```
1. 模型初始化时（models/molopt_score_model.py:297-298）
   ↓
   self.dynamic_large_step_defaults = getattr(config, 'dynamic_large_step', {})
   self.dynamic_refine_defaults = getattr(config, 'dynamic_refine', {})
   ↓
   ✅ 这里仍然读取训练配置（作为初始默认值）
   
2. _run_unified_dynamic 函数开始（scripts/sample_diffusion.py:42-59）
   ↓
   dynamic_cfg = config.sample.get('dynamic', {})  # ✅ 从 sampling.yml 读取
   ↓
   if 'large_step' in dynamic_cfg:
       original_large_step_defaults = getattr(model, 'dynamic_large_step_defaults', {})
       model.dynamic_large_step_defaults = {**original_large_step_defaults, **dynamic_cfg['large_step']}
       # ✅ 关键：用 sampling.yml 中的配置更新模型的默认值
   ↓
   if 'refine' in dynamic_cfg:
       original_refine_defaults = getattr(model, 'dynamic_refine_defaults', {})
       model.dynamic_refine_defaults = {**original_refine_defaults, **dynamic_cfg['refine']}
       # ✅ 关键：用 sampling.yml 中的配置更新模型的默认值
   
3. 调用 dynamic_sample_diffusion（scripts/sample_diffusion.py:92-102）
   ↓
   result = model.dynamic_sample_diffusion(...)
   ↓
   ✅ 虽然仍然只传递了 num_steps, center_pos_mode, pos_only
   ✅ 但是模型的默认值已经被更新了！
   
4. dynamic_sample_diffusion 方法内部（models/molopt_score_model.py:1290-1291）
   ↓
   large_cfg = self.dynamic_large_step_defaults or {}  # 读取模型属性
   refine_cfg = self.dynamic_refine_defaults or {}     # 读取模型属性
   ↓
   ✅ 这里读取的是已经更新后的值（包含 sampling.yml 中的配置）
   
5. 使用配置参数
   ↓
   step_size=large_cfg.get('step_size')  # ✅ 使用 sampling.yml 中的值
   stride=large_cfg.get('stride')         # ✅ 使用 sampling.yml 中的值
   ↓
   ✅ sampling.yml 中的配置被正确使用
```

## 关键代码解析

### 修改的核心代码（第49-59行）

```python
# 从 sampling.yml 读取 dynamic 配置并更新模型的默认值
if 'large_step' in dynamic_cfg:
    # 1. 获取模型当前的默认值（来自训练配置）
    original_large_step_defaults = getattr(model, 'dynamic_large_step_defaults', {})
    
    # 2. 使用字典合并，将 sampling.yml 中的配置合并到默认值中
    model.dynamic_large_step_defaults = {
        **original_large_step_defaults,      # 先展开原始默认值
        **dynamic_cfg['large_step']          # 再展开 sampling.yml 中的配置（会覆盖相同键）
    }
```

### 字典合并的工作原理

```python
# 假设：
original_large_step_defaults = {
    'stride': 50,        # 训练时的默认值
    'step_size': 1.0,    # 训练时的默认值
    'pos_clip': None     # 训练时的默认值
}

dynamic_cfg['large_step'] = {
    'stride': 100,       # sampling.yml 中指定的值
    'step_size': 2.0,    # sampling.yml 中指定的值
    'noise_scale': 0.1   # sampling.yml 中新增的值
}

# 合并后：
model.dynamic_large_step_defaults = {
    'stride': 100,       # ✅ 被 sampling.yml 覆盖
    'step_size': 2.0,    # ✅ 被 sampling.yml 覆盖
    'pos_clip': None,    # ✅ 保留原始值（因为 sampling.yml 中没有）
    'noise_scale': 0.1   # ✅ 新增的值
}
```

## 为什么这样设计有效？

### 1. **利用了现有的架构**
- `dynamic_sample_diffusion` 方法已经设计为从 `self.dynamic_large_step_defaults` 读取配置
- 我们不需要修改模型方法，只需要在调用前更新模型的属性即可

### 2. **保持了向后兼容性**
- 如果 `sampling.yml` 中没有某些配置项，会保留训练时的默认值
- 如果 `sampling.yml` 中只有部分配置项，未指定的项会使用训练时的默认值

### 3. **时机正确**
- 在采样循环**之前**更新配置，确保所有样本都使用相同的配置
- 在调用 `dynamic_sample_diffusion` **之前**更新，确保方法读取到正确的值

### 4. **作用域合适**
- 只更新当前函数调用期间的模型属性
- 不会影响其他地方的模型使用（因为是在函数内部临时更新）

## 完整的数据流

```
sampling.yml
  ↓
config.sample.get('dynamic', {})  [第42行]
  ↓
dynamic_cfg['large_step']         [第50行检查]
  ↓
{**original, **dynamic_cfg['large_step']}  [第54行合并]
  ↓
model.dynamic_large_step_defaults = {...}  [第54行更新]
  ↓
model.dynamic_sample_diffusion()  [第92行调用]
  ↓
self.dynamic_large_step_defaults  [第1290行读取]
  ↓
large_cfg.get('step_size')        [第1305行使用]
  ↓
✅ 参数被正确使用！
```

## 对比：修改前 vs 修改后

### 修改前
```
sampling.yml 中的配置
  ↓
❌ 被忽略，从未被读取
  ↓
使用训练时的默认值
```

### 修改后
```
sampling.yml 中的配置
  ↓
✅ 被读取并更新到模型属性
  ↓
✅ 被 dynamic_sample_diffusion 使用
  ↓
✅ 参数被正确应用
```

## 总结

修改的关键在于：

1. **在正确的时机**（采样循环之前）更新模型的默认配置
2. **使用字典合并**保留未覆盖的原始默认值
3. **利用现有架构**，不需要修改模型方法本身
4. **保持兼容性**，如果配置缺失会使用训练时的默认值

这样，`sampling.yml` 中的配置就能在 unified 模式下正常使用了！

