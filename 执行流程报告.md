# sample_diffusion.py 执行流程报告

## 概述
本报告详细描述了启动 `D:\DiffDynamic\scripts\sample_diffusion.py` 时的完整执行流程，包括调用的数据库、进行的操作、使用的代码块和调用的函数。

---

## 一、初始化阶段

### 1.1 命令行参数解析
**代码块**: `lines 606-614`
**调用的函数**: 
- `argparse.ArgumentParser()` - 创建参数解析器
- `parser.add_argument()` - 添加命令行参数定义
- `parser.parse_args()` - 解析命令行参数

**操作**:
- 解析配置文件路径 (`config`)
- 解析数据索引 (`-i, --data_id`)
- 解析运行设备 (`--device`, 默认 `cuda:0`)
- 解析批量大小 (`--batch_size`, 默认 100)
- 解析结果输出路径 (`--result_path`, 默认 `./outputs`)
- 解析采样模式 (`--mode`, 可选 `baseline` 或 `dynamic`)

---

### 1.2 日志系统初始化
**代码块**: `line 616`
**调用的函数**: 
- `misc.get_logger('sampling')` - 创建日志记录器

**操作**:
- 创建名为 'sampling' 的日志器
- 配置控制台输出处理器
- 设置日志格式为: `[时间::名称::级别] 消息`

**相关函数实现** (`utils/misc.py:35-60`):
- `logging.getLogger()` - 获取日志器实例
- `logging.StreamHandler()` - 创建控制台处理器
- `logging.Formatter()` - 设置日志格式

---

### 1.3 配置文件加载
**代码块**: `lines 619-620`
**调用的函数**: 
- `misc.load_config(args.config)` - 加载 YAML 配置文件
- `misc.seed_all(config.sample.seed)` - 设置随机种子

**操作**:
- 读取 YAML 配置文件并转换为 `EasyDict` 对象
- 设置 PyTorch、NumPy 和 Python random 模块的随机种子

**相关函数实现** (`utils/misc.py:29-32, 75-79`):
- `yaml.safe_load()` - 安全加载 YAML 文件
- `EasyDict()` - 转换为可属性访问的字典
- `torch.manual_seed()`, `np.random.seed()`, `random.seed()` - 设置随机种子

---

## 二、模型加载阶段

### 2.1 检查点加载
**代码块**: `lines 624-625`
**调用的函数**: 
- `torch.load(config.model.checkpoint, map_location=args.device)` - 加载模型检查点

**操作**:
- 从检查点文件加载模型权重和训练配置
- 将检查点映射到指定设备（CPU 或 GPU）
- 记录训练配置信息到日志

**数据库/文件访问**:
- 读取检查点文件（通常为 `.pt` 或 `.pth` 格式）
- 包含: `model` (模型权重), `config` (训练配置), 可能包含优化器状态等

---

### 2.2 特征转换器初始化
**代码块**: `lines 628-635`
**调用的函数**: 
- `trans.FeaturizeProteinAtom()` - 创建蛋白原子特征化器
- `trans.FeaturizeLigandAtom(ligand_atom_mode)` - 创建配体原子特征化器
- `trans.FeaturizeLigandBond()` - 创建配体键特征化器
- `Compose([...])` - 组合多个转换器

**操作**:
- 从检查点配置中读取 `ligand_atom_mode`（配体原子编码模式）
- 创建蛋白原子特征提取器
- 创建配体原子特征提取器（根据模式）
- 创建配体键特征提取器
- 将转换器组合为单一转换管道

**使用的代码块**:
- `utils/transforms.py` - 特征转换模块

---

## 三、数据集加载阶段

### 3.1 数据集实例化
**代码块**: `lines 638-643`
**调用的函数**: 
- `get_dataset(config=ckpt['config'].data, transform=transform)` - 加载数据集

**操作**:
- 根据检查点中的数据集配置加载数据集
- 应用特征转换管道到每个样本

**相关函数实现** (`datasets/__init__.py:12-39`):
- 根据 `config.name` 判断数据集类型:
  - `'pl'` → `PocketLigandPairDataset` (口袋-配体配对数据集)
  - `'pdbbind'` → `PDBBindDataset` (PDBBind 数据集)
- 如果配置中包含 `split` 字段，加载拆分文件并创建子集

**数据库/文件访问**:
- 读取数据集根目录 (`config.path`)
- 读取拆分文件 (`config.split`, 如果存在) - 通常为 `.pt` 格式
- 访问数据集中的蛋白-配体对文件

**返回结果**:
- `dataset`: 完整数据集对象
- `subsets`: 字典，包含 `{'train': train_set, 'test': test_set, ...}`

---

### 3.2 数据集子集提取
**代码块**: `line 642`
**操作**:
- 从 `subsets` 字典中提取训练集和测试集
- `train_set, test_set = subsets['train'], subsets['test']`

---

### 3.3 选择测试样本
**代码块**: `line 657`
**操作**:
- 根据命令行参数 `args.data_id` 从测试集中选择特定样本
- `data = test_set[args.data_id]`

**数据访问**:
- 访问测试集索引位置的数据
- 返回 `ProteinLigandData` 对象，包含:
  - 蛋白坐标 (`protein_pos`)
  - 蛋白原子特征 (`protein_atom_feature`)
  - 配体坐标 (`ligand_pos`, 如果存在)
  - 配体原子特征 (`ligand_atom_feature`, 如果存在)
  - 其他元数据

---

## 四、模型构建与加载阶段

### 4.1 模型配置读取
**代码块**: `lines 646-648`
**操作**:
- 从检查点中提取模型配置: `model_cfg = ckpt['config'].model`
- 获取模型名称: `model_name = getattr(model_cfg, 'name', 'score').lower()`

---

### 4.2 模型类选择与实例化
**代码块**: `lines 648-653`
**调用的函数**: 
- `GlintDM()` 或 `ScorePosNet3D()` - 根据模型名称选择模型类
- `model.to(args.device)` - 将模型移动到指定设备

**操作**:
- 如果 `model_name == 'glintdm'`，使用 `GlintDM` 类
- 否则使用 `ScorePosNet3D` 类
- 使用模型配置、蛋白特征维度、配体特征维度初始化模型
- 将模型移动到 GPU 或 CPU

**模型类定义**:
- `models/molopt_score_model.py:282-549` - `ScorePosNet3D` 类
- `models/molopt_score_model.py:1185-1301` - `GlintDM` 类（继承自 `ScorePosNet3D`）

**模型初始化过程** (`ScorePosNet3D.__init__`):
1. 设置扩散调度参数（beta 调度、alpha 累积等）
2. 初始化时间嵌入模块 (`SinusoidalPosEmb`)
3. 初始化原子嵌入层 (`protein_atom_emb`, `ligand_atom_emb`)
4. 初始化精炼网络 (`refine_net`):
   - `get_refine_net()` - 根据 `model_type` 选择网络类型
   - `'uni_o2'` → `UniTransformerO2TwoUpdateGeneral`
   - `'egnn'` → `EGNN`
5. 初始化原子类型预测头 (`v_inference`)

---

### 4.3 模型权重加载
**代码块**: `line 654`
**调用的函数**: 
- `model.load_state_dict(ckpt['model'])` - 加载模型权重

**操作**:
- 将检查点中的模型权重加载到模型实例
- 恢复训练时的模型状态

---

## 五、采样模式选择

### 5.1 采样模式确定
**代码块**: `lines 658-660`
**操作**:
- 优先使用命令行参数 `args.mode`
- 如果未提供，使用配置文件中的 `config.sample.get('mode', 'baseline')`
- 验证模式是否为 `'baseline'` 或 `'dynamic'`

---

## 六、采样执行阶段

### 6.1 动态采样模式 (`mode == 'dynamic'`)

#### 6.1.1 动态配置初始化
**代码块**: `lines 662-665`
**操作**:
- 确保 `config.sample.dynamic` 配置存在
- 设置大步采样批量大小（如果未指定，使用命令行参数 `args.batch_size`）

---

#### 6.1.2 执行动态采样
**代码块**: `lines 666-673`
**调用的函数**: 
- `sample_dynamic_diffusion_ligand()` - 动态采样入口函数

**函数实现** (`lines 473-499`):
- 读取动态配置: `config.sample.get('dynamic', {})`
- 确定动态方法: `dynamic_method = dynamic_cfg.get('method', 'auto')`
- 检查模型是否支持统一动态接口: `hasattr(model, 'dynamic_sample_diffusion')`
- 根据方法选择执行路径:
  - `'unified'` → `_run_unified_dynamic()`
  - `'legacy'` → `_run_legacy_dynamic()`

---

#### 6.1.2.1 统一动态采样 (`_run_unified_dynamic`)

**代码块**: `lines 29-126`

**主要操作流程**:

1. **配置读取** (`lines 42-47`):
   - 读取动态采样配置参数
   - 获取样本数量、步数、中心化模式等

2. **样本循环** (`lines 55-114`):
   对每个样本执行:
   
   a. **批次构建** (`line 56`):
      - `Batch.from_data_list([data.clone()], follow_batch=FOLLOW_BATCH).to(device)`
      - 将单个样本包装为批次
   
   b. **原子数量采样** (`lines 59-71`):
      - 根据 `sample_num_atoms_mode` 选择策略:
        - `'prior'`: 根据口袋空间大小采样原子数
          - `atom_num.get_space_size()` - 计算口袋空间大小
          - `atom_num.sample_atom_num()` - 采样原子数量
        - `'range'`: 按序递增原子数量
        - `'ref'`: 使用参考配体的原子数
   
   c. **初始位置生成** (`lines 73-74`):
      - `scatter_mean()` - 计算蛋白中心
      - `torch.randn()` - 生成随机初始配体位置
   
   d. **初始类别分布** (`lines 76-77`):
      - 创建均匀的 log 概率分布
      - `F.log_softmax()` - 归一化为 log 概率
   
   e. **执行动态采样** (`lines 80-90`):
      - **调用的核心函数**: `model.dynamic_sample_diffusion()`
      
      **函数实现** (`models/molopt_score_model.py:1229-1301`):
      - 读取大步和精炼配置
      - 调用 `model.sample_diffusion_large_step()` - 大步探索阶段
      - 调用 `model.sample_diffusion_refinement()` - 精炼阶段
      - 合并两个阶段的轨迹
      
      **大步采样** (`sample_diffusion_large_step`, `lines 950-1025`):
      - 中心化坐标: `center_pos()`
      - 构建时间调度: `_build_lambda_schedule()` 或固定步长
      - 执行动态扩散: `_dynamic_diffusion()`
      
      **精炼采样** (`sample_diffusion_refinement`, `lines 1028-1110`):
      - 中心化坐标
      - 构建时间调度（通常更密集）
      - 执行多周期动态扩散
      
      **动态扩散核心** (`_dynamic_diffusion`, `lines 820-947`):
      对每个时间步:
      1. 模型前向传播: `self()` → `forward()`
      2. 计算后验均值: `q_pos_posterior()`
      3. 计算梯度（局部和全局）:
         - 局部梯度: `pos_model_mean - ligand_pos`
         - 全局梯度: `pos0_from_e - ligand_pos`
      4. 梯度融合（如果启用）: `lambda * global + (1-lambda) * local`
      5. 梯度裁剪: `clamp_by_norm()`
      6. 更新位置: `ligand_pos = ligand_pos + step_size * grad`
      7. 更新类别（如果未设置 `pos_only`）:
         - 计算类别梯度: `cal_kl_gradient()`
         - 更新 log 概率: `F.log_softmax()`
      8. 记录轨迹（如果启用）
   
   f. **结果提取** (`lines 93-104`):
      - 提取最终坐标和类别
      - 提取轨迹数据
      - 记录耗时和元信息

3. **结果汇总** (`lines 115-126`):
   - 收集所有样本的结果
   - 返回包含位置、类别、轨迹、耗时等的字典

---

#### 6.1.2.2 传统动态采样 (`_run_legacy_dynamic`)

**代码块**: `lines 259-470`

**主要操作流程**:

1. **配置读取** (`lines 273-280`):
   - 读取大步、精炼、筛选器配置

2. **大步探索阶段** (`lines 292-372`):
   - 构建大批次（`large_batch_size` 个样本）
   - 执行大步采样: `model.sample_diffusion_large_step()`
   - 对每个候选进行评估: `evaluate_candidate()`
   - 收集所有候选

3. **候选筛选** (`lines 374-377`):
   - `select_top_candidates()` - 根据评分选择 top-N 候选
   - 评分基于 QED 和 SA 指标

4. **精炼阶段** (`lines 382-445`):
   - 对每个选中的候选执行精炼
   - `model.sample_diffusion_refinement()` - 精炼采样
   - 再次评估精炼后的结果

5. **结果汇总** (`lines 450-470`):
   - 收集所有精炼后的结果

---

#### 6.1.2.3 候选评估 (`evaluate_candidate`)

**代码块**: `lines 168-231`

**调用的函数**:
- `trans.get_atomic_number_from_index()` - 将类别索引转换为原子序号
- `trans.is_aromatic_from_index()` - 获取芳香标记
- `reconstruct.reconstruct_from_generated()` - 从坐标和原子类型重建分子
- `Chem.MolToSmiles()` - 转换为 SMILES 字符串
- `scoring_func.get_chem()` - 计算化学指标（QED、SA）

**操作**:
1. 将类别数组转换为原子序号
2. 重建 RDKit 分子对象
3. 转换为 SMILES
4. 计算 QED（药物相似性）和 SA（合成可达性）分数
5. 根据权重计算综合评分: `sa_weight * sa - qed_weight * qed`
6. 应用阈值过滤（如果配置了 `min_qed` 或 `max_sa`）

**分子重建过程** (`utils/reconstruct.py:455-518`):
1. `make_obmol()` - 从坐标和原子序号创建 OpenBabel 分子
2. `fixup()` - 调整原子属性（芳香性等）
3. `connect_the_dots()` - 根据距离连接键
4. `mol.PerceiveBondOrders()` - 感知键级
5. `mol.AddHydrogens()` - 添加氢原子
6. `convert_ob_mol_to_rd_mol()` - 转换为 RDKit 分子
7. `postprocess_rd_mol_1()`, `postprocess_rd_mol_2()` - 后处理

---

#### 6.1.3 动态采样结果整理
**代码块**: `lines 674-684`
**操作**:
- 将动态采样输出整理为统一的结果字典格式
- 包含: 预测位置、类别、轨迹、耗时、元信息等

---

### 6.2 基线采样模式 (`mode == 'baseline'`)

**代码块**: `lines 686-693`
**调用的函数**: 
- `sample_diffusion_ligand()` - 标准扩散采样函数

**函数实现** (`lines 502-603`):

**主要操作流程**:

1. **批次循环** (`lines 527-602`):
   对每个批次:
   
   a. **批次构建** (`line 529`):
      - `Batch.from_data_list([data.clone() for _ in range(n_data)], ...)`
   
   b. **原子数量采样** (`lines 534-545`):
      - 与动态采样类似的策略
   
   c. **初始位置和类别** (`lines 548-557`):
      - 计算蛋白中心并生成随机初始位置
      - 如果 `pos_only=True`，复用原始类别；否则生成均匀类别分布
   
   d. **执行标准扩散采样** (`lines 559-570`):
      - **调用的核心函数**: `model.sample_diffusion()`
      
      **函数实现** (`models/molopt_score_model.py:1113-1182`):
      - 中心化坐标
      - 从 `num_timesteps - num_steps` 到 `num_timesteps - 1` 逆序遍历时间步
      - 对每个时间步:
        1. 模型前向传播: `self()`
        2. 计算后验均值和方差: `q_pos_posterior()`, `posterior_logvar`
        3. 采样下一个位置: `pos_model_mean + noise * sqrt(variance)`
        4. 如果未设置 `pos_only`，采样下一个类别: `log_sample_categorical()`
        5. 记录轨迹
      - 返回最终位置、类别和完整轨迹
   
   e. **轨迹拆分** (`lines 574-599`):
      - `unbatch_v_traj()` - 将批次轨迹拆分为单个样本的轨迹
      - 提取位置轨迹、类别轨迹、v0 轨迹、vt 轨迹

2. **结果返回** (`line 603`):
   - 返回所有样本的位置、类别、轨迹和耗时列表

---

#### 6.2.1 基线采样结果整理
**代码块**: `lines 694-704`
**操作**:
- 将基线采样输出整理为结果字典
- 包含: 预测位置、类别、轨迹（包括 v0 和 vt 轨迹）、耗时等

---

## 七、模型前向传播详解

### 7.1 模型 forward 函数

**代码块**: `models/molopt_score_model.py:494-549`

**主要操作流程**:

1. **配体输入准备** (`line 498`):
   - `_prepare_ligand_inputs()` - 将输入转换为统一格式（log 概率）

2. **时间嵌入** (`lines 500-512`):
   - 如果启用时间嵌入:
     - `'simple'`: 拼接归一化时间标量
     - `'sin'`: 使用正弦位置编码 (`SinusoidalPosEmb`)
   - `self.time_emb()` - 生成时间嵌入向量

3. **原子嵌入** (`lines 514-515`):
   - `self.protein_atom_emb(protein_v)` - 蛋白原子特征嵌入
   - `self.ligand_atom_emb(input_ligand_feat)` - 配体原子特征嵌入

4. **节点类型指示器** (`lines 517-519`):
   - 如果启用，为蛋白节点添加 0，配体节点添加 1

5. **上下文组合** (`lines 521-528`):
   - `compose_context()` - 拼接蛋白和配体节点
   - 创建统一的图结构，包含所有节点坐标、特征和批次索引

6. **精炼网络前向传播** (`line 530`):
   - `self.refine_net()` - 调用精炼网络
   
   **UniTransformer 前向传播** (`models/uni_transformer.py:306-333`):
   - 对每个块 (`num_blocks`):
     a. **图构建** (`line 312`):
        - `_connect_edge()` - 根据当前坐标构建边
        - 支持 `radius`, `knn`, `hybrid` 模式
     b. **边类型编码** (`line 316`):
        - `_build_edge_type()` - 生成边类型独热编码（4 类: l-l, l-p, p-l, p-p）
     c. **注意力层更新** (`lines 325-326`):
        - 对每层 (`num_layers`):
          - `AttentionLayerO2TwoUpdateNodeGeneral()` - 同时更新特征和坐标
          - **x2h 更新**: 从坐标到特征 (`BaseX2HAttLayer`)
          - **h2x 更新**: 从特征到坐标 (`BaseH2XAttLayer`)
     d. **记录轨迹** (`lines 327-328`)

7. **原子类型预测** (`line 533`):
   - `self.v_inference(final_ligand_h)` - 通过 MLP 预测原子类型 logits

8. **返回结果** (`lines 535-549`):
   - 返回预测的位置、类别 logits
   - 如果 `return_all=True`，返回所有层的中间结果

---

## 八、结果保存阶段

### 8.1 输出目录准备
**代码块**: `lines 707-708`
**调用的函数**: 
- `os.makedirs(result_path, exist_ok=True)` - 创建输出目录

**操作**:
- 创建结果输出目录（如果不存在）

---

### 8.2 配置文件备份
**代码块**: `line 709`
**调用的函数**: 
- `shutil.copyfile(args.config, os.path.join(result_path, 'sample.yml'))` - 复制配置文件

**操作**:
- 将采样配置文件复制到输出目录，命名为 `sample.yml`

---

### 8.3 结果保存
**代码块**: `line 710`
**调用的函数**: 
- `torch.save(result, os.path.join(result_path, f'result_{args.data_id}.pt'))` - 保存结果

**操作**:
- 将采样结果保存为 PyTorch 文件
- 文件名格式: `result_{data_id}.pt`

**保存的内容** (`result` 字典):
- `data`: 原始输入数据
- `pred_ligand_pos`: 预测的配体坐标列表
- `pred_ligand_v`: 预测的配体原子类型列表
- `pred_ligand_pos_traj`: 位置轨迹列表
- `pred_ligand_v_traj`: 类别轨迹列表
- `pred_ligand_log_v_traj`: log 概率轨迹列表（仅动态模式）
- `pred_ligand_v0_traj`, `pred_ligand_vt_traj`: v0 和 vt 轨迹（仅基线模式）
- `time`: 采样耗时列表
- `meta`: 元信息（采样方法、原子数、时间调度等）
- `mode`: 采样模式（'baseline' 或 'dynamic'）

---

## 九、关键函数调用链总结

### 9.1 动态采样调用链
```
sample_dynamic_diffusion_ligand()
  └─> _run_unified_dynamic() 或 _run_legacy_dynamic()
       └─> model.dynamic_sample_diffusion()  (统一模式)
            ├─> model.sample_diffusion_large_step()
            │    └─> model._dynamic_diffusion()
            │         └─> model.forward()
            │              └─> model.refine_net()
            │                   └─> UniTransformerO2TwoUpdateGeneral.forward()
            └─> model.sample_diffusion_refinement()
                 └─> model._dynamic_diffusion()
                      └─> (同上)
       
       或
       
       └─> _run_legacy_dynamic()
            ├─> model.sample_diffusion_large_step()
            │    └─> (同上)
            ├─> evaluate_candidate()
            │    └─> reconstruct.reconstruct_from_generated()
            │         └─> make_obmol(), connect_the_dots(), etc.
            ├─> select_top_candidates()
            └─> model.sample_diffusion_refinement()
                 └─> (同上)
```

### 9.2 基线采样调用链
```
sample_diffusion_ligand()
  └─> model.sample_diffusion()
       └─> 循环时间步:
            └─> model.forward()
                 └─> model.refine_net()
                      └─> UniTransformerO2TwoUpdateGeneral.forward()
```

---

## 十、数据库和文件访问总结

### 10.1 读取的文件
1. **配置文件**: YAML 格式的采样配置文件
2. **模型检查点**: PyTorch 格式 (`.pt` 或 `.pth`)
   - 包含: 模型权重、训练配置、可能包含优化器状态
3. **数据集文件**:
   - 数据集根目录中的蛋白-配体对文件
   - 拆分文件 (`.pt` 格式，包含 train/val/test 索引)
4. **数据集内容** (根据数据集类型):
   - **PocketLigandPairDataset**: 口袋-配体配对数据
   - **PDBBindDataset**: PDBBind 数据库文件

### 10.2 写入的文件
1. **结果文件**: `result_{data_id}.pt` - 包含所有采样结果
2. **配置文件备份**: `sample.yml` - 采样配置的副本
3. **日志输出**: 控制台输出（如果配置了文件日志，还会写入日志文件）

---

## 十一、关键数据流

### 11.1 输入数据流
```
配置文件 (YAML)
  └─> config 对象
       ├─> 模型配置
       ├─> 数据集配置
       └─> 采样配置

检查点文件 (.pt)
  └─> ckpt 字典
       ├─> model: 模型权重
       └─> config: 训练配置

数据集文件
  └─> ProteinLigandData 对象
       ├─> protein_pos: [N_protein, 3]
       ├─> protein_atom_feature: [N_protein, feature_dim]
       ├─> ligand_pos: [N_ligand, 3] (可选)
       └─> ligand_atom_feature: [N_ligand, feature_dim] (可选)
```

### 11.2 处理数据流
```
输入数据
  └─> 特征转换 (transforms)
       └─> 批次化 (Batch.from_data_list)
            └─> 模型前向传播
                 ├─> 原子嵌入
                 ├─> 时间嵌入
                 ├─> 上下文组合
                 ├─> 精炼网络 (UniTransformer)
                 │    ├─> 图构建
                 │    ├─> x2h 更新 (特征)
                 │    └─> h2x 更新 (坐标)
                 └─> 类型预测头
                      └─> 输出: 位置预测, 类别 logits
```

### 11.3 输出数据流
```
模型输出
  └─> 采样结果字典
       ├─> pred_ligand_pos: [num_samples, num_atoms, 3]
       ├─> pred_ligand_v: [num_samples, num_atoms]
       ├─> pos_traj: [num_samples, num_steps, num_atoms, 3]
       ├─> v_traj: [num_samples, num_steps, num_atoms]
       └─> 其他元数据
            └─> 保存为 .pt 文件
```

---

## 十二、关键参数和配置

### 12.1 采样配置参数
- `num_samples`: 生成样本数量
- `num_steps`: 扩散步数
- `batch_size`: 批量大小
- `center_pos_mode`: 坐标中心化模式 ('protein' 或 'none')
- `pos_only`: 是否仅采样位置
- `sample_num_atoms`: 原子数量策略 ('prior', 'range', 'ref')

### 12.2 动态采样配置
- `dynamic.method`: 动态方法 ('unified' 或 'legacy')
- `dynamic.large_step.*`: 大步探索配置
- `dynamic.refine.*`: 精炼阶段配置
- `dynamic.selector.*`: 候选筛选配置

### 12.3 模型配置参数
- `model_type`: 精炼网络类型 ('uni_o2' 或 'egnn')
- `hidden_dim`: 隐藏维度
- `num_blocks`, `num_layers`: 网络结构参数
- `beta_schedule`: 扩散调度类型
- `num_diffusion_timesteps`: 扩散时间步数

---

## 十三、执行时间线

1. **初始化** (~0.1s): 参数解析、日志创建、配置加载
2. **模型加载** (~1-5s): 检查点加载、模型实例化、权重加载
3. **数据集加载** (~1-10s): 数据集实例化、样本选择（取决于数据集大小）
4. **采样执行** (~10s-数分钟): 
   - 基线模式: 每个样本 ~1-10s（取决于步数和原子数）
   - 动态模式: 每个样本 ~10-60s（包含大步和精炼阶段）
5. **结果保存** (~0.1s): 文件写入

**总执行时间**: 通常为 10 秒到数分钟，取决于:
- 样本数量
- 扩散步数
- 原子数量
- 设备性能（CPU/GPU）
- 采样模式（基线 vs 动态）

---

## 十四、错误处理和边界情况

### 14.1 配置验证
- 检查采样模式是否有效
- 验证模型是否支持请求的动态方法
- 检查原子数量策略是否有效

### 14.2 数据验证
- 确保数据集索引有效
- 检查数据格式是否正确

### 14.3 模型验证
- 确保检查点文件存在且可读
- 验证模型配置与检查点匹配
- 检查设备可用性（GPU/CPU）

---

## 十五、依赖关系

### 15.1 外部库依赖
- **PyTorch**: 深度学习框架
- **PyTorch Geometric**: 图神经网络
- **RDKit**: 分子处理
- **OpenBabel**: 分子格式转换（通过 pybel）
- **NumPy**: 数值计算
- **YAML**: 配置文件解析
- **tqdm**: 进度条显示

### 15.2 内部模块依赖
- `models/molopt_score_model`: 扩散模型实现
- `models/uni_transformer`: UniTransformer 网络
- `datasets`: 数据集加载
- `utils/transforms`: 特征转换
- `utils/reconstruct`: 分子重建
- `utils/evaluation`: 评估函数
- `utils/misc`: 通用工具

---

## 总结

本报告详细描述了 `sample_diffusion.py` 的完整执行流程，包括:
- 15 个主要执行阶段
- 50+ 个关键函数调用
- 多个数据库和文件访问点
- 完整的数据流和处理流程

该脚本实现了基于扩散模型的配体生成采样流程，支持两种采样模式（基线和动态），能够生成符合蛋白口袋约束的配体分子结构。

